# Spot Market

This system generates synths (ERC-20 tokens) and markets that exchange them with stablecoins generated by [Synthetix](../../protocol/synthetix) at a rate determined by the [oracle manager](../../protocol/oracle-manager).

To execute trades, the market will withdraw or deposit stablecoins with Synthetix (negatively or positively impacting the position of liquidity providers to the market, respectively). The market also reports the total supply of the issued synths multiplied by their current price to the system as debt, such that the synths are collateralized by liquidity providers in Synthetix.

The amount of collateral necessary to back these synths (minus the value of the collateral provided to the market via the wrappers, if any) is locked. In other words, liquidity providers cannot remove delegated credit such that the issued synths would become undercollateralized.

## Creating Synths

To create a new synth and a corresponding market, call `registerSynth(string memory tokenName, string memory tokenSymbol, address synthOwner)`. This function returns a market ID, which can be used in a pool's configuration within Synthetix to provide
it with liquidity. The `getSynth(uint128 marketId)` function returns the address of the synth deployed for the specified market. The `synthOwner` address has the ability to configure prices and fees on the market.

### Configuring Prices

The owner of a market may call `function updatePriceData(uint128 marketId, bytes32 buyNodeId, bytes32 sellNodeId)` to set the price feeds that should be used by the specified market. The node ids must first be registered with the [oracle manager](../../protocol/oracle-manager).

### Configuring Fees

The owner of the market may set the configure fees and relevant settings using the functions exposed by the [IFeeConfigurationModule interface](./contracts/interfaces/IFeeConfigurationModule.sol).

## Types of Transactions

This market implementation allows synths to be exchanged with stablecoins using three different transaction types: atomic orders, asyncronous orders, and wrapping.

### Atomic Orders

The market allows traders to buy or sell synths in a single (atomic) transaction. The relevant logic is included in the [Atomic Order Module](./contracts/modules/AtomicOrderModule.sol).

To buy a synth in an atomic order, a trader may call `buy(uint128 marketId, uint usdAmount)` with the market id relevant to the synth they'd like to purchase and the amount of stablecoins they'd like to provide for the exchange. The trader must first `approve()` the transfer of the amount of stablecoins to the market.

To sell a synth in an atomic order, a trader may call `sell(uint128 marketId, uint synthAmount)` with the market id relevant to the synth they'd like to sell and the amount of synths they'd like to provide for the exchange. The trader must first `approve()` the transfer of the amount of synths to the market.

Traders may simulate calling these functions with `callStatic` to retrieve a quote of how much would have been provided in the exchange.

#### Fees

- `uint atomicFixedFee` - This fee (denominated as a percentage with 18 decimals) is applied to both buy and sell atomic orders.
- `mapping(address => uint) atomicFixedFeeOverrides` - This is a mapping of fees (denominated as a percentage with 18 decimals) that will be used instead of `atomicFixedFee` when `msg.sender` is found in the mapping.

### Asyncronous Orders

Asyncronous orders involve two transactions: a _commitment_ and a _settlement_. This reduces composability, but allows for front-running mitigation such that lower fees can be offered to traders. Asyncronous orders may be cancelled under certain circumstances. The relevant logic is included in the [Async Order Module](./contracts/modules/AsyncOrderModule.sol).

The market owner can configure various _settlement strategies_ for asyncronous orders. Each settlement strategy can be defined with the following properties:

- **Type** - There are three types of settlement strategies:
  - On-chain: Use the price provided by the oracle manager upon settlement
  - Chainlink: Use Chainlink-verifiable price data related to the settlement time.
  - Pyth: Use Pyth-verifiable price data related to the settlement time.
- **Fixed Fee**: This fee (denominated as a percentage with 18 decimals) is applied to both buy and sell asyncronous orders using this settlement strategy. (This is strongly recommended to mitigate front-running for on-chain settlements.)
- **Settlement Delay** - This is added to the timestamp associated with the block when the commitment is made to determine the settlement time. (This is strongly recommended to mitigate front-running for on-chain settlements.)
- **Settlement Window Duration** - The duration after the settlement time at which an order expires. If zero, unlimited. (This is strongly recommended to mitigate trader optionality for on-chain settlements.)
- **Price Verification Contract**: For Chainlink and Pyth settlement strategies. _t.b.d._
- **Price Deviation Circuit Breaker Node ID** - For Chainlink and Pyth settlement strategies. _t.b.d._
- **Price Deviation Circuit Breaker Tolerance** - For Chainlink and Pyth settlement strategies. _t.b.d._

The following actions are involved with executing (or cancelling) asyncronous orders:

- **Commit**
  - The trader deposits assets (stablecoins for a buy, synths for a sell) into escrow
  - The trader is issued an Async Order NFT that tracks: the order type, the amount escrowed, the settlement strategy to use, the settlement time, the estimated fill (to be factored into the utilization fee), and the estimated fee (to be used during cancellation).
- **Settle**
  - While in the settlement window, anyone can settle the order. The holder of the Async Order NFT receives the assets in the exchange. The price is determined differently based on the settlement strategy associated with the order:
    - On-chain: The price provided by the oracle manager at the time of this transaction is used, assuming that the timestamp associated with the price is at least as old as the settlement time.
    - Chainlink: The off-chain price data for the settlement time is used, assuming it successfully verified by Chainlink and passes any configured circuit breaking.
    - Pyth: The off-chain price data for the settlement time is used, assuming it successfully verified by Pyth and passes any configured circuit breaking.
- **Cancel**
  - The holder of the async order NFT may cancel the related order at any time. They receive the assets in escrow, minus the fee calculated at the time of commitment.
  - After the settlement window duration elapses, forcing the order into expiration, anyone can cancel the order. The holder of the relevant async order NFT receives the assets in escrow, minus the fee calculated at the time of commitment.
  - The market owner may cancel and order at any time. In this case, Tte holder of the relevant async order NFT receives the entire value of the assets in escrow (including the estimated fee).

#### Fees

The fixed fee associated with the settlement strategy is used for any given order.

### Wrapping

Markets which are able to [provide collateral directly to Synthetix](../../protocol/synthetix/contracts/modules/core/MarketCollateralModule.sol) can issue synths of equivalent value after applying fees. The relevant logic is included in the [Wrapper Module](./contracts/modules/WrapperModule.sol).

To wrap collateral and receive a synth, a trader may call `wrap(uint128 marketId, uint wrapAmount)` with the market id relevant to the synth they'd like to wrap and the amount of collateral they'd like to provide for the exchange. The trader must first `approve()` the transfer of the amount of collateral to the market.

To unwrap a synth and receive collateral, a trader may call `unwrap(uint128 marketId, uint unwrapAmount)` with the market id relevant to the synth they'd like to unwrap and the amount of synths they'd like to provide for the exchange. The trader must first `approve()` the transfer of the amount of synths to the market.

Traders may simulate calling these functions with `callStatic` to retrieve a quote of how much would have been provided in the exchange.

#### Fees

- `int wrapFixedFee` - This fee (denominated as a percentage with 18 decimals) is applied when collateral is wrapped and synths are issued. Note that this fee may be negative.
- `int unwrapFixedFee` - This fee (denominated as a percentage with 18 decimals) is applied when collateral is unwrapped and synths are burned. Note that this fee may be negative.

## Additional Fees and Configuration

In addition to the fees specific to transaction types outlined above, the following fees may be applied for different effects. Some or all of the fees may also be processed by a custom fee collector, rather than returned to liquidity providers directly.

### Supply Target Fee

A supply target fee helps limit liquidity providers' exposure to price fluctuations of the asset in situations where demand becomes very high. The amount of liquidity provided to a market implies a _supply target_ (i.e. a utilization rate of 100%) which is a maximum amount of synths the market should issue. Over this amount, the market can apply a supply target fee on atomic and asyncronous buy transactions to limit its synth issuance.

The market owner can set the fee rate with the function `setMarketUtilizationFees()`. This is percentage (denominated as a percentage with 18 decimal places) that is applied to to determine the resulting fee rate. For instance, if a buy order would move the utilization rate from 90% to 120%, the average utilization rate resulting from the order would be 105%. This is a 5% excess. If the fee rate is set to 100%, a 5% fee is applied. If the fee rate is set to 50%, a 2.5% fee would be applied, etc.

### Simulated Slippage Fee

_t.c._

### Auto-Rebalancing Skew Fee

An auto-rebalancing skew fee allows a market to use wrapping functionality in such a way that reduces protocol risk. A (positive or negative) fee could be applied as a function of _market skew_, defined as the total supply of synths minus the amount of wrapped collateral. This creates an arbitrage opportunity that will pull the skew back into a tolerance range defined by the function.

The market owner can set the skew scale with the function `setMarketSkewScale()`. The skew scale is the amount we divide the current market skew by to determine the fee rate.

### Custom Fee Collector

The owner of a market can deploy a custom fee collector contract (which conforms to the [IFeeCollector interface](./contracts/interfaces/external/IFeeCollector.sol)) and attach it to their market with the `setFeeCollector()` function.

When a custom fee collector has been set, after each transaction, the market will approve the value of the collected fees (as stablecoins) to be used by the fee collector contract and then call `collectFees()` on it. Any fees not transferred out of the market by this call will be deposited to liquidity providers in Synthetix.

### Interest Rate

The owner of a market can set an interest rate (denominated as an annual percentage with 18 decimal places) for the synths issued by their market with the `setInterestRate()` function. This is implemented as a rebase token, where the total supply (and holders' individual balances) will automatically decay at the rate specified.

Though synth decay can complicate some considerations related to composability, this allows liquidity providers to be incentivized to back synths that tend to be held over long periods of time rather than actively exchanged.

## Development

`npm start`
